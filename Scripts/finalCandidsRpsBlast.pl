# Developed by Carlos Fischer - 20 Oct 2020
# Updated: 02 Aug 2022

# To generate the final candidates for RPS-Blast, for all considered TE types

# If a sequence (whole or short) has no domains with e-value equal or below the threshold ("$filterRpsBlast"), the ID of that sequence will not be shown in the output files.

####
# Usage: perl finalCandidsRpsBlast.pl
# This script would be launched by CombTEs.pl
####


# The input file can be generated by the "extractRPSB.pl" script, which extracts and formats the predictions from the original output file of RPS-Blast. Such a script names its output file as "ConservedDomains_NoRedund.pred"; this is the name used here in "finalCandidsRpsBlast.pl".
# In such a file, the predictions of RPS-Blast must be in this format (all together):
# DOMAIN--dom_ID_in_CDD---FROM--ff---TO--tt---LENGTH--ll---EVALUE--ev---SCORE--sc---SENSE--Direct/Reverse
# "ff", "tt", and "ll" are integer.

# There is NO limit for the lengths of the RPS-Blast's predictions.


# This script uses 4 parameters:
# - 2 of them can be changed in "ParamsGeneral.pm":
#	- @TEtypes: the considered TE types;
#	- %filterTools: threshold for the predictions' e-values (default = 1.0e-05)
# - 2 others can be changed in "ParamsRpsblast.pm":
#	- $distPredsRPSB: maximum distance between 2 predictions to consider them inside the SAME candidate (default = 300);
#	- %domains: conserved domains considered in the analyses (after running RPS-Blast), for:
#		- Bel:   DUF1759, Peptidase_A17, DUF1758, RT_pepA17;
#		- Copia: Retrotran_gag, gag_pre-integrs, RVT_2, RNase_HI_RT_Ty1;
#		- Gypsy: Retrotrans_gag, gag-asp_proteas, retropepsin_like, RP_Saci_like, RVP_2, RT_LTR, RVT_3, RNase_HI_RT_Ty3, 			  RNase_HI_like;
#		- and:   rve (Integrase), for Bel, Copia, and Gypsy.

###########################################################################################

use strict;
use warnings;

use Cwd qw(getcwd);
use lib getcwd(); 

use ParamsGeneral qw(@TEtypes %filterTools);
use ParamsRpsblast qw(%domains $distPredsRPSB);

my $filterRpsBlast = $filterTools{'RpsBlast'};
# DO NOT CHANGE the value of "$filterTools{'RpsBlast'}" directly here; change it in "%filterTools" in "ParamsGeneral.pm" package

###########################################################################################


my $fileConsDoms = "ConservedDomains_NoRedund.pred"; # RPS-Blast predictions
open (PREDFILE, $fileConsDoms) or die "\nCan't open $fileConsDoms!!!\n\n";
my @linesINRpsb = <PREDFILE>;
close (PREDFILE);

my $qttLinesIN = scalar(@linesINRpsb);

my $finalCandids = "finalCandidates_RpsBlast.txt";
open (CANDIDS, ">$finalCandids") or die "\nCan't open $finalCandids!!!\n\n";
print CANDIDS "Final candidates of RPS-Blast, with the domain predictions used to generate each final candidate.\n";
print CANDIDS "Maximum distance between two predictions to consider them inside the same candidate: $distPredsRPSB.\n";
print CANDIDS "Threshold for the predictions' e-values: $filterRpsBlast.\n\n";

my $newCandid = "yes";
my $numCandid;
my $i = 0;
my ($teType, $startCandid, $endCandid, $senseCandid, $typeCandid, @arrayOfCandid, @arrayToPrint);

while ($i < $qttLinesIN) {
	my $line = $linesINRpsb[$i]; chomp $line;

	if ($line =~ />>>SEQUENCE/) {
		push (@arrayToPrint, $line);
		$newCandid = "yes";
		@arrayOfCandid = ();
		$numCandid = 0;
		$i++;
	} # IF ($line =~ />>>SEQUENCE/)

#			 DOMAIN--dom---FROM--ff---TO--tt---LENGTH--ll---EVALUE--eval---SCORE--sc---SENSE--D/R
	elsif ($line =~ /DOMAIN--(.*)---FROM--(\d+)---TO--(\d+)---LENGTH--.*---EVALUE--(.*)---SCORE--.*---SENSE--(.*)/) {
		my $dom    = $1;
		my $from   = $2;
		my $to     = $3;
		my $evalue = $4;
		my $sense  = $5;

		if ($evalue <= $filterRpsBlast) {
			if ($dom eq "rve") { $teType = "inconclusive"; } # "rve" (integrase) may be found in several superfamilies
			else {
				foreach my $type (@TEtypes) {
					if ($dom =~ $domains{$type}) { $teType = $type; }
				}
			}

			if ($newCandid eq "yes") {
				$startCandid = $from;
				$endCandid   = $to;
				$senseCandid = $sense;
				$typeCandid  = $teType;
				@arrayOfCandid = ();
				push (@arrayOfCandid, $line);
				$newCandid = "no";
				$i++;
			}
			else { # ($newCandid eq "no") (it is the same candidate)
				if ( ($sense eq $senseCandid) and ( ($teType eq $typeCandid) or ($teType eq "inconclusive") or ($typeCandid eq "inconclusive") ) and (($from - $endCandid) <= $distPredsRPSB) ) {
	# it will be a new candidate only if: "different senses" OR "different TE types", OR "dist(from-endCandid) > distPredsRPSB"
					if ($typeCandid eq "inconclusive") { $typeCandid = $teType; }
					if ($to > $endCandid) { $endCandid = $to; }
					push (@arrayOfCandid, $line);
					$i++;
				}
				else { $newCandid = "yes"; } # found a new candidate: write the current one
			} # ELSE { # $newCandid eq "no"
		} # IF ($evalue <= $filterRpsBlast)
		else { $i++; }

		if ( ($newCandid eq "yes") or ($i == $qttLinesIN) or ($linesINRpsb[$i] eq "###\n") ) {
		# it is a NEW candidate OR end of the current sequence: write the current candidate
			my $qttInCandid = scalar(@arrayOfCandid);
			if ($qttInCandid != 0) {
				$numCandid++;
				my $lengthCandid = $endCandid - $startCandid + 1;
				my $idCandid = "CANDIDATE_$numCandid - FROM: $startCandid - TO: $endCandid - LENGTH: $lengthCandid - SENSE: $senseCandid - CLASSIFICATION: $typeCandid";
				push (@arrayToPrint, $idCandid);

				for (my $j = 0; $j < $qttInCandid; $j++) { push (@arrayToPrint, $arrayOfCandid[$j]); }
				$newCandid = "yes";
			} # IF ($qttInCandid != 0)
		} # IF ( ($newCandid eq "yes") or ...
	} # ELSIF ($line =~ /DOMAIN--(.*)---FROM-- ...
	elsif ($line eq "###") {
		my $qttToPrint = scalar(@arrayToPrint);
		if ($qttToPrint > 1) {
			foreach my $lineCand (@arrayToPrint) {
				if ($lineCand =~ /CANDIDATE_(\d+) - FROM/) {
					if ($1 != 1) { print CANDIDS "\n"; }
				}
				print CANDIDS "$lineCand\n";
				print "$lineCand\n"; # output to CombTEs
			}
			print CANDIDS "$line\n\n";
			print "$line\n"; # output to CombTEs
		} # IF ($qttToPrint > 1)
		@arrayToPrint = ();
		$i++;
	}
	else { $i++; }

} # WHILE ($i < $qttLinesIN)

close (CANDIDS);

