# Developed by Carlos Fischer - 20 Oct 2020
# Updated: 29 Jan 2021

# To generate the final candidates for HMMER and RepeatMasker, for all superfamilies.
# It generates also a separate file with the (initial) candidates for each superfamily for each tool.

# The script verifies, for each tool, if there is overlap between CANDIDATES from different superfamilies; for this, it calculates (using the "$maxPercCandidOutOverlap" percentage) the maximum size of the smallest candidate outside the overlapping region ("$maxSizeOutOverlap") to consider the overlap as acceptable - in this case, the best predicted candidate (based on the lowest E-value or the highest SW score) defines the superfamily classification for such a region (the "final candidate"), for each tool.

####
# Usage: perl finalCandidsHmmerRM.pl TOOL
# It is launched by CombTEs.pl
####

# The input file can be generated by the "extractHmmerRM.pl" script, which extracts and formats the predictions from the output file of HMMER and RepeatMasker. Such a script names its output file as "SUPERFAM_TOOL.pred" (like "Bel_HMMER.pred" and "Copia_RepeatMasker.pred"); this is the name used here in "finalCandidsHmmerRM.pl".


# This script uses 9 parameters:
# - 2 of them can be changed in "ParamsGeneral.pm":
#	- @superfamilies: the used superfamilies;
#	- %filterTools: values of the filter(s) for HMMER and RepeatMasker considered in the analyses. 

# - 7 others can be changed in "ParamsHmmerRM.pm":
#   1 is a common parameter for both tools:
#	- $maxPercCandidOutOverlap: maximum percentage of the smallest CANDIDATE allowed to be outside the overlapping region, to 		consider the overlap as acceptable (default = 0.50 == 50% - a lower value would increase the number of CANDIDATES for a tool).
#   2 parameters used only by HMMER:
#	- $distPredsHMMER: maximum distance between 2 predictions to consider them inside the SAME candidate (default = 300);
#	- $minLenPredHMMER: minimum length for a HMMER's prediction to be included in the analyses (default = 20);
#   4 others used only by RepeatMasker:
#	- $distPredsRepeatMasker: maximum distance between 2 predictions to consider them inside the SAME candidate (default = 300);
#	- $minLenPredRepeatMasker: minimum length for a RepeatMasker's prediction to be included in the analyses (default = 20);
#	- $pattLtrs: the patterns used in Repbase to describe a sequence as a specific LTR one (default = "-LTR|_LTR");
#	- $includeLTRs: to consider ("yes") or not ("no") LTR predictions in the analyses (default = "no").

###########################################################################################

use strict;
use warnings;

use Cwd qw(getcwd);
use lib getcwd(); 

use ParamsGeneral qw(@superfamilies %filterTools);
use ParamsHmmerRM qw($maxPercCandidOutOverlap $distPredsHMMER $distPredsRepeatMasker $minLenPredHMMER $minLenPredRepeatMasker $pattLtrs $includeLTRs);

my $filterHMMER        = $filterTools{'HMMER'};
my $filterRepeatMasker = $filterTools{'RepeatMasker'};
# DO NOT CHANGE the values of "$filterHMMER" and "$filterRepeatMasker" directly here; change them in "%filterTools" in "ParamsGeneral.pm" package.

###########################################################################################

sub verifyOverlap { # to verify overlap between 2 CANDIDATES and, if so, retrieve the ID of the one to be disregarded; this candidate would be:
# - for HMMER:        the one with the highest e-value or, for the same e-values, the shortest candidate
# - for RepeatMasker: the one with the lowest SWscore or,  for the same SWscores, the shortest candidate.

    (my $method, my $seq1, my $seq2) = @_;

    my ($from1, $to1, $length1, $evalSWs1, $sense1);
    my ($from2, $to2, $length2, $evalSWs2, $sense2);

# For HMMER:
# $seq= Candidate_1 - FROM: ff - TO: tt - LENGTH: ll - EVALUE: ev - SENSE: dr - CLASSIFICATION: spfam\nPREDIC---FROM-- etc.
# For RepeatMasker:
# $seq= Candidate_1 - FROM: ff - TO: tt - LENGTH: ll - SWSCORE: s - SENSE: dr - CLASSIFICATION: spfam\nPREDIC---FROM-- etc.
    if (
	($seq1 =~ /FROM: (.*) - TO: (.*) - LENGTH: (.*) - (EVALUE|SWSCORE): (.*) - SENSE: (.*) - CLASSIFICATION/)
       ) {
	$from1    = $1;
	$to1      = $2;
	$length1  = $3;
	$evalSWs1 = $5;
	$sense1   = $6;
    }
    if (
	($seq2 =~ /FROM: (.*) - TO: (.*) - LENGTH: (.*) - (EVALUE|SWSCORE): (.*) - SENSE: (.*) - CLASSIFICATION/)
       ) {
	$from2    = $1;
	$to2      = $2;
	$length2  = $3;
	$evalSWs2 = $5;
	$sense2   = $6;
    }

    my $respOverl = "NONE"; # define that there is NOT overlap between seq_1 and seq_2; otherwise, it retrieves the ID of the candidate to be disregarded
    if ($sense1 eq $sense2) {
	my $hasOverlap = "no";
#     testing if candidates are apart from each other
	if ( ($to1 > $from2) and ($to2 > $from1) ) {
#	  calculating the maximum size ("$maxSizeOutOverlap" - according to the length of the smallest candidate) outside the 		  overlapping region to consider the overlap as acceptable:
	    my $referLength = $length1;
	    if ($length2 < $length1) { $referLength = $length2; }
	    my $maxSizeOutOverlap = $maxPercCandidOutOverlap * $referLength;

#	  IF: (seq_2 inside seq_1) OR (seq_1 inside seq_2) --->> overlap between predictions
	    if ( ( ($from1 <= $from2) and ($to2 <= $to1) ) or ( ($from2 <= $from1) and ($to1 <= $to2) ) ) { $hasOverlap = "yes"; }
#	  testing the maximum allowed region outside the overlap
	    elsif ( (abs($from1-$from2) <= $maxSizeOutOverlap) or (abs($to1-$to2) <= $maxSizeOutOverlap) )
	        # IF SO, overlap between predictions
		  { $hasOverlap = "yes"; }
	} # IF ( ($to1 > $from2) and ($to2 > $from1) )

	if ($hasOverlap eq "yes") { # there is overlap between seq_1 and seq_2
	    if ($method eq "HMMER") {
		if    ($evalSWs1 < $evalSWs2) { $respOverl = "JJ"; }
		elsif ($evalSWs1 > $evalSWs2) { $respOverl = "II"; }
		else {
		    if ($length1 >= $length2) { $respOverl = "JJ"; }	
		    else		      { $respOverl = "II"; }
		}
	    }
	    elsif ($method eq "RepeatMasker") {
		if    ($evalSWs1 > $evalSWs2) { $respOverl = "JJ"; }
		elsif ($evalSWs1 < $evalSWs2) { $respOverl = "II"; }
		else {
		    if ($length1 >= $length2) { $respOverl = "JJ"; }	
		    else		      { $respOverl = "II"; }
		}
	    }
	} # IF ($hasOverlap eq "yes")
    } # IF ($sense1 eq $sense2)

    return ($respOverl, $sense1, $sense2);
} # END of SUB "verifyOverlap"

###########################################################################################


my $tool = $ARGV[0];

my ($metrics, $maxDistPreds);
if ($tool eq "HMMER") {
	$metrics = "EVALUE";
	$maxDistPreds = $distPredsHMMER;
}
elsif ($tool eq "RepeatMasker") {
	$metrics = "SWSCORE";
	$maxDistPreds = $distPredsRepeatMasker;
}

my @candidAllSuperfam = (); # for all candidates (of all superfamilies) from each tool for FINAL classification
foreach my $superfam (@superfamilies) {
	my $inPred = "$superfam\_$tool";

   	my $predFile = "$inPred.pred"; # file with predictions of each superfamily from each tool
   	open (PREDFILE, $predFile) or die "Can't open $predFile!!!";

	my $toolCandids = "finalCandidates_$tool.txt";
	open (TOOLCANDIDS, ">$toolCandids") or die "Can't open $toolCandids";

	my $spfamCandids = "$inPred-candidates.pred"; # for the candidates of each superfamily (for each tool)
	open (SPFAMCANDIDS, ">$spfamCandids") or die "Can't open $spfamCandids!!!";
	print SPFAMCANDIDS "Candidates of $tool for \*$superfam\* superfamily, from file \"$predFile\".\n";
	print SPFAMCANDIDS "Maximum distance between two predictions to consider them inside the same candidate: $maxDistPreds.\n";
	if    ($tool eq "HMMER") { print SPFAMCANDIDS "Filter for E-value and length: $filterHMMER and $minLenPredHMMER.\n\n"; }
	elsif ($tool eq "RepeatMasker") { print SPFAMCANDIDS "Filter for SWscore and length: $filterRepeatMasker and $minLenPredRepeatMasker.\n\n"; }

### filtering predictions based on e-values for HMMER OR SWscores for RepeatMasker, AND based on the lengths for both tools
	my @candidSuperfam = ();
	while (not eof PREDFILE) {
	    my $line = readline(PREDFILE); chomp $line;
# from the input files:
# from HMMER:	PREDIC---FROM--ff---TO--tt---LENGTH--ll---EVALUE--ev---SCORE--sc---SENSE--d/r---SUPERFAM--sf
# from RM:	PREDIC---FROM--ff---TO--tt---LENGTH--ll---SWSCORE--sc---SENSE--dr---MATCHINGREPEAT--match---SUPERFAM--sf
	    if ($line =~ /LENGTH--(\d+)---EVALUE--(.*)---SCORE/) {
		my $lengPred = $1;
		my $evalue   = $2;
		if ( ($evalue <= $filterHMMER) and ($lengPred >= $minLenPredHMMER) ) { push (@candidSuperfam, $line); }
	    }
	    elsif ($line =~ /LENGTH--(\d+)---SWSCORE--(\d+)---SENSE--.*---MATCHINGREPEAT--(.*)---SUPERFAM/) {
		my $lengPred = $1;
		my $swscore  = $2;
		my $matchRep = $3;
		if ( ($swscore >= $filterRepeatMasker) and ($lengPred >= $minLenPredRepeatMasker) ) {
		    if ( ($includeLTRs eq "yes") or ($matchRep !~ /$pattLtrs/) ) { push (@candidSuperfam, $line); }
		}
	    }
	} # WHILE (not eof PREDFILE)
### END of filtering predictions
	close (PREDFILE);

## generating candidates of EACH superfamily (for each tool)
	my $qttSpfam = scalar(@candidSuperfam);
	my $newCandid = "yes";
	my $numCandid = 0;
	my $i = 0;
	my ($from, $to, $evalSws, $sense, $startCandid, $endCandid, $evalSwsCand, $senseCandid);
	my @arrayPrint;
	while ($i < $qttSpfam) {
		my $lineSpf = $candidSuperfam[$i];
		if ($lineSpf =~ /FROM--(\d+)---TO--(\d+)---LENGTH/) {
			$from = $1;
			$to   = $2;
		}
		if ($lineSpf =~ /EVALUE--(.*)---SCORE--.*---SENSE--(.*)---SUPERFAM/) {
			$evalSws = $1;
			$sense   = $2;
		}
		elsif ($lineSpf =~ /SWSCORE--(\d+)---SENSE--(.*)---MATCHINGREPEAT/) {
			$evalSws = $1;
			$sense   = $2;
		}

		if ($newCandid eq "yes") {
			$startCandid = $from;
			$endCandid   = $to;
			$evalSwsCand = $evalSws;
			$senseCandid = $sense;

			@arrayPrint = ();
			push (@arrayPrint, $lineSpf);
			$newCandid = "no";
			$i++;
		}
		else { # ($newCandid eq "NO")
			if ( ($sense eq $senseCandid) and (($from - $endCandid) <= $maxDistPreds) ) {
				if ($to > $endCandid) { $endCandid = $to; }
				if ($tool eq "HMMER")		{ if ($evalSws < $evalSwsCand) { $evalSwsCand = $evalSws; } }
				elsif ($tool eq "RepeatMasker")	{ if ($evalSws > $evalSwsCand) { $evalSwsCand = $evalSws; } }
				push (@arrayPrint, $lineSpf);
				$i++;
			}
			else { $newCandid = "yes"; }
		}

		if ( ($newCandid eq "yes") or ($i == $qttSpfam) ) {
			$numCandid++;
			my $lengthCandid = $endCandid - $startCandid + 1;
			my $idCandid = "Candidate_$numCandid - FROM: $startCandid - TO: $endCandid - LENGTH: $lengthCandid - $metrics: $evalSwsCand - SENSE: $senseCandid - CLASSIFICATION: $superfam";
			print SPFAMCANDIDS "$idCandid\n";
			my $qttToPrint = scalar(@arrayPrint);
			for (my $j = 0; $j < $qttToPrint; $j++) { print SPFAMCANDIDS "$arrayPrint[$j]\n"; }
			print SPFAMCANDIDS "###\n";

			for (my $j = 0; $j < $qttToPrint; $j++) { $idCandid .= "\n$arrayPrint[$j]"; } 
			push (@candidAllSuperfam, {line => $idCandid, from => $startCandid});
		}
	} # WHILE ($i < $qttSpfam)
## END of generating candidates of each superfamily

	close (SPFAMCANDIDS);
} # FOREACH $superfam (@superfamilies)


## Generating the FINAL CANDIDATES for all superfamilies together for each tool:
print TOOLCANDIDS "Final candidates of $tool, with the predictions used to generate each one.\n";
print TOOLCANDIDS "Maximum distance between two predictions to consider them inside the same candidate: $maxDistPreds.\n";
if    ($tool eq "HMMER")        { print TOOLCANDIDS "Filter for E-value and length: $filterHMMER and $minLenPredHMMER.\n\n"; }
elsif ($tool eq "RepeatMasker") { print TOOLCANDIDS "Filter for SWscore and length: $filterRepeatMasker and $minLenPredRepeatMasker.\n\n"; }

my @auxSorted = sort{ $a->{from} <=> $b->{from} } @candidAllSuperfam;
my @sortedCandidAllSuperfam = ();
foreach my $lineAux (@auxSorted) { push (@sortedCandidAllSuperfam, $lineAux->{line}); }

## Verifying possible overlap between 2 CANDIDATES:
my $qttCandid = scalar(@sortedCandidAllSuperfam);
for (my $i = 0; $i < $qttCandid-1; $i++) {
    for (my $j = $i+1; $j < $qttCandid; $j++) {
	if ($sortedCandidAllSuperfam[$i] =~ /-->OUT/) { last; }
	if ($sortedCandidAllSuperfam[$j] !~ /-->OUT/) {
		my ($resp, $sense1, $sense2) = verifyOverlap ($tool, $sortedCandidAllSuperfam[$i], $sortedCandidAllSuperfam[$j]);
		if    ($resp eq "II") { $sortedCandidAllSuperfam[$i] .= "-->OUT"; }
		elsif ($resp eq "JJ") { $sortedCandidAllSuperfam[$j] .= "-->OUT"; }
		elsif ($sense1 eq $sense2) { last; }
	}
    }
}

my $numCandid = 0;
for (my $i = 0; $i < $qttCandid; $i++) {
    if ($sortedCandidAllSuperfam[$i] !~ /-->OUT/) {
	$numCandid++;
# for HMMER: Candidate_num - FROM: ff - TO: tt - LENGTH: ll - EVALUE: ev - SENSE: d/r - CLASSIFICATION: sf 
# for RM:    Candidate_num - FROM: ff - TO: tt - LENGTH: ll - SWSCORE: sc - SENSE: d/r - CLASSIFICATION: sf
	if ($sortedCandidAllSuperfam[$i] =~ /Candidate_\d+ - (.*)- $metrics: .* - SENSE: (.*)/) {
		my $idCandid = "CANDIDATE_$numCandid - $1- SENSE: $2";
		print TOOLCANDIDS "$idCandid\n";
		print "$idCandid\n";

#		write the predictions used to generate the candidate
		my @arraySplit = split '\n',$sortedCandidAllSuperfam[$i];
		my $qttSepara = scalar(@arraySplit);
		for (my $j = 1; $j < $qttSepara; $j++) {
			print TOOLCANDIDS "$arraySplit[$j]\n";
			print "$arraySplit[$j]\n";
		}
		print TOOLCANDIDS "\n";
		print "###\n";
	}
    }
}

close (TOOLCANDIDS);

