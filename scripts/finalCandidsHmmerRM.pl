# Developed by Carlos Fischer - 20 Oct 2020

# To generate the final candidates of HMMER and RepeatMasker, for all superfamilies.
# It generates also a separate file with the candidates for each superfamily of each tool.

# Usage: perl finalCandidsHmmerRM.pl TOOL

# The input file "SUPERFAM_TOOL.pred" ("Bel_HMMER.pred", "Copia_RepeatMasker.pred", etc.) can be generated by the script "extractHmmerRM.pl", which extracts and formats the predictions from the output file of HMMER and RepeatMasker.
# In such a file, there is NO redundancy between predictions inside a subsequence
# BUT there may be redundancy between predictions of 2 subsequences for predictions in the overlapping region of these 2 subsequences;
# this "finalCandidsHmmerRM.pl" script takes care of this.


# This script uses 11 parameters:
# - 2 of them can be changed in "ParamsGeneral.pm":
#	- @superfamilies: the used superfamilies;
#	- %filterTools: values of the filter(s) for HMMER and RepeatMasker considered in the analyses. 

# - 9 others can be changed in "ParamsHmmerRM.pm":
#   3 of them are common parameters for both tools:
#	- $varExtr: to allow small variation between respective extremities for cases of overlapping between 2 predictions (default= 		50).
#	- $minOverlPred: minimum value to consider that there is overlapping between two predictions (default = 100 - a higher value 		would increase the number of predictions to be considered in the following analyses);
#	- $maxOverlCand: maximum value of overlap between 2 candidates to consider them SEPARATE final candidates (default = 100); setting a value greater than "$maxOverlCand", the 2 candidates will be considered only one;

#   1 parameters are used only by HMMER:
#	- $distPredsHMMER: maximum distance between 2 predictions to consider them inside the SAME candidate (default = 300);

#   5 others only by RepeatMasker:
#	- $distPredsRepeatMasker: maximum distance between 2 predictions to consider them inside the SAME candidate (default = 500);
#	- $minLenPred: minimum length for a prediction to be included in the analyses (default = 100);
#	- $minSwscore: minimum score to consider a "short" prediction in the analyses: if (length < $minLenPred), its SWscore must be >= $minSwscore (default = 500);
#	- $pattLtrs: the patterns used in Repbase to describe a sequence as a specific LTR one (default = "-LTR|_LTR");
#	- $includeLTRs: to consider ("yes") or not ("no") LTR predictions in the analyses (default = "no").

###########################################################################################

use strict;
use warnings;

use Cwd qw(getcwd);
use lib getcwd(); 

use ParamsGeneral qw(@superfamilies %filterTools);
use ParamsHmmerRM qw($varExtr $minOverlPred $maxOverlCand $distPredsHMMER $distPredsRepeatMasker $minLenPred $minSwscore $pattLtrs $includeLTRs);

my $filterHMMER        = $filterTools{'HMMER'};
my $filterRepeatMasker = $filterTools{'RepeatMasker'};
# DO NOT CHANGE the values of "$filterHMMER" and "$filterRepeatMasker" directly here; change them in "%filterTools" in "ParamsGeneral.pm" package.

###########################################################################################

sub verifyOverlap { # to verify overlap between 2 candidates and, if so, retrieve an ID of the one to be disregarded; this candidate would be:
# - for HMMER:        the one with the highest e-value or, for the same e-values, the shortest candidate
# - for RepeatMasker: the one with the lowest SWscore or,  for the same SWscores, the shortest candidate.

	(my $method, my $seq1, my $seq2) = @_;

	my ($from1, $to1, $length1, $evalSWs1, $sense1);
	my ($from2, $to2, $length2, $evalSWs2, $sense2);

# For HMMER:
# $seq= Candidate_1 - FROM: ff - TO: tt - LENGTH: ll - EVALUE: ev - SENSE: dr - CLASSIFICATION: spfam\nPREDIC---FROM-- etc.
# For RepeatMasker:
# $seq= Candidate_1 - FROM: ff - TO: tt - LENGTH: ll - SWSCORE: s - SENSE: dr - CLASSIFICATION: spfam\nPREDIC---FROM-- etc.
	if (
	     ($seq1 =~ /FROM: (.*) - TO: (.*) - LENGTH: (.*) - (EVALUE|SWSCORE): (.*) - SENSE: (.*) - CLASSIFICATION/)
	   ) {
		$from1    = $1;
		$to1      = $2;
		$length1  = $3;
		$evalSWs1 = $5;
		$sense1   = $6;
	}
	if (
	     ($seq2 =~ /FROM: (.*) - TO: (.*) - LENGTH: (.*) - (EVALUE|SWSCORE): (.*) - SENSE: (.*) - CLASSIFICATION/)
	   ) {
		$from2    = $1;
		$to2      = $2;
		$length2  = $3;
		$evalSWs2 = $5;
		$sense2   = $6;
	}

	my $respOverl = "NONE"; # there is NOT overlap between seq_1 and seq_2 OR retrieve an ID of the prediction to be disregarded
	if ($sense1 eq $sense2) {
	    if ( ($from2 <= $to1) or ($to2 >= $from1) ) {
		if (
		    (abs($from1-$from2) <= $varExtr) or (abs($to1-$to2) <= $varExtr) or # small variation in corresponding extremities
		    (($from1 < $from2) and ($to2 <  $to1)) or				# seq_2 inside seq_1
		    (($from2 < $from1) and ($to1 <  $to2)) or				# seq_1 inside seq_2
		    (($from1 < $from2) and (($to1 - $from2) >= $maxOverlCand)) or	# overlap >= $maxOverlCand
		    (($to2   < $to1)   and (($to2 - $from1) >= $maxOverlCand))
		   ) { # there is overlap between seq_1 and seq_2
			if ($method eq "HMMER") {
				if    ($evalSWs1 < $evalSWs2) { $respOverl = "JJ"; }
				elsif ($evalSWs1 > $evalSWs2) { $respOverl = "II"; }
				else {
					if ($length1 >= $length2) { $respOverl = "JJ"; }	
					else			  { $respOverl = "II"; }
				} 
			}
			elsif ($method eq "RepeatMasker") {
				if ( ($length1 >= $minLenPred) and ($length2 >= $minLenPred) ) { 
					if    ($evalSWs1 > $evalSWs2) { $respOverl = "JJ"; }
					elsif ($evalSWs1 < $evalSWs2) { $respOverl = "II"; }
					else {
						if ($length1 >= $length2) { $respOverl = "JJ"; }	
						else			  { $respOverl = "II"; }
					}
				}
				else {
					if ($length1 >= $length2) { $respOverl = "JJ"; }	
					else			  { $respOverl = "II"; }
				}
			}
		} # IF ( (abs($from1-$from2) <= $varExtr) or ....
	    } # IF ( ($from2 < $to1) or ($to2 > $from1) )
	} # IF ($sense1 eq $sense2)

#	return "$respOverl";
	return ($respOverl, $sense1, $sense2);
} # END of SUB "verifyOverlap"

###########################################################################################

my $tool = $ARGV[0];

my ($metrics, $maxDistPreds);
if ($tool eq "HMMER") {
	$metrics = "EVALUE";
	$maxDistPreds = $distPredsHMMER;
}
elsif ($tool eq "RepeatMasker") {
	$metrics = "SWSCORE";
	$maxDistPreds = $distPredsRepeatMasker;
}

my @candidAllSuperfam = (); # for all candidates of each tool for FINAL classification

foreach my $superfam (@superfamilies) {
	my $inPred = "$superfam\_$tool";

   	my $predFile = "$inPred.pred"; # file with predictions of each superfamily from each tool
   	open (PREDFILE, $predFile) or die "Can't open $predFile!!!";

	my $toolCandids = "finalCandidates_$tool.txt";
	open (TOOLCANDIDS, ">$toolCandids") or die "Can't open $toolCandids";

	my $spfamCandids = "$inPred-candidates.pred"; # for the candidates of each superfamily (for each tool)
	open (SPFAMCANDIDS, ">$spfamCandids") or die "Can't open $spfamCandids!!!";
	print SPFAMCANDIDS "Candidates of $tool for \*$superfam\* superfamily, from file \"$predFile\".\n";
	print SPFAMCANDIDS "Maximum distance between two predictions to consider them inside the same candidate: $maxDistPreds.\n";
	if    ($tool eq "HMMER") { print SPFAMCANDIDS "Filter for e-values: $filterHMMER.\n\n"; }
	elsif ($tool eq "RepeatMasker") { print SPFAMCANDIDS "Filters for SWscores and length: $filterRepeatMasker and $minLenPred - for a \"short\" prediction (length < $minLenPred), its SWscore must be >= $minSwscore.\n\n"; }

### filtering predictions based on e-values for HMMER OR based on SWscores, $minLenPred, and $minSwscore for RepeatMasker
	my @candidSuperfam = ();
	while (not eof PREDFILE) {
		my $line = readline(PREDFILE); chomp $line;
# from the input files:
# from HMMER:	PREDIC---FROM--ff---TO--tt---LENGTH--ll---EVALUE--ev---SCORE--sc---SENSE--d/r---SUPERFAM--sf
# from RM:	PREDIC---FROM--ff---TO--tt---LENGTH--ll---SWSCORE--sc---SENSE--dr---MATCHINGREPEAT--match---SUPERFAM--sf
		if ($line =~ /EVALUE--(.*)---SCORE/) {
			my $evalue = $1;
			if ($evalue <= $filterHMMER) { push (@candidSuperfam, $line); }
		}
		elsif ($line =~ /LENGTH--(.*)---SWSCORE--(.*)---SENSE--.*---MATCHINGREPEAT--(.*)---SUPERFAM/) {
			my $lengPred = $1;
			my $swscore  = $2;
			my $matchRep = $3;
			if ($swscore >= $filterRepeatMasker) {
			   if ( ($lengPred >= $minLenPred) or ($swscore >= $minSwscore) ) {
			      if ( ($includeLTRs eq "yes") or ($matchRep !~ /$pattLtrs/) ) { push (@candidSuperfam, $line); }
			   }
			}
		}
	} # WHILE
### END of filtering predictions
	close (PREDFILE);


## generating candidates of EACH superfamily (for each tool)
	my $qttSpfam = scalar(@candidSuperfam);
	my $newCandid = "yes";
	my $numCandid = 0;
	my $i = 0;
	my ($from, $to, $evalSws, $sense, $startCandid, $endCandid, $evalSwsCand, $senseCandid);
	my @arrayPrint;
	while ($i < $qttSpfam) {
		my $lineSpf = $candidSuperfam[$i];
		if ($lineSpf =~ /FROM--(\d+)---TO--(\d+)---LENGTH/) {
			$from = $1;
			$to   = $2;
		}
		if ($lineSpf =~ /EVALUE--(.*)---SCORE--.*---SENSE--(.*)---SUPERFAM/) {
			$evalSws = $1;
			$sense   = $2;
		}
		elsif ($lineSpf =~ /SWSCORE--(\d+)---SENSE--(.*)---MATCHINGREPEAT/) {
			$evalSws = $1;
			$sense   = $2;
		}

		if ($newCandid eq "yes") {
			$startCandid = $from;
			$endCandid   = $to;
			$evalSwsCand = $evalSws;
			$senseCandid = $sense;

			@arrayPrint = ();
			push (@arrayPrint, $lineSpf);
			$newCandid = "no";
			$i++;
		}
		else { # ($newCandid eq "NO")
			if ( ($sense eq $senseCandid) and (($from - $endCandid) <= $maxDistPreds) ) {
				if ($to > $endCandid) { $endCandid = $to; }
				if ($tool eq "HMMER")		{ if ($evalSws < $evalSwsCand) { $evalSwsCand = $evalSws; } }
				elsif ($tool eq "RepeatMasker")	{ if ($evalSws > $evalSwsCand) { $evalSwsCand = $evalSws; } }
				push (@arrayPrint, $lineSpf);
				$i++;
			}
			else { $newCandid = "yes"; }
		}

		if ( ($newCandid eq "yes") or ($i == $qttSpfam) ) {
			$numCandid++;
			my $lengthCandid = $endCandid - $startCandid + 1;
			my $idCandid = "Candidate_$numCandid - FROM: $startCandid - TO: $endCandid - LENGTH: $lengthCandid - $metrics: $evalSwsCand - SENSE: $senseCandid - CLASSIFICATION: $superfam";
			print SPFAMCANDIDS "$idCandid\n";
			my $qttToPrint = scalar(@arrayPrint);
			for (my $j = 0; $j < $qttToPrint; $j++) { print SPFAMCANDIDS "$arrayPrint[$j]\n"; }
			print SPFAMCANDIDS "###\n";

			for (my $j = 0; $j < $qttToPrint; $j++) { $idCandid .= "\n$arrayPrint[$j]"; } 
			push (@candidAllSuperfam, {line => $idCandid, from => $startCandid});
		}
	} # WHILE ($i < $qttSpfam)
## END of generating candidates of each superfamily

	close (SPFAMCANDIDS);
} # FOREACH $superfam (@superfamilies)


## Generating the final candidates for all superfamilies together:
print TOOLCANDIDS "Final candidates of $tool, with the predictions used to generate each candidate.\n";
print TOOLCANDIDS "Maximum distance between two predictions to consider them inside the same candidate: $maxDistPreds.\n";
if ($tool eq "HMMER") { print TOOLCANDIDS "Filter for e-values: $filterHMMER.\n\n"; }
elsif ($tool eq "RepeatMasker") { print TOOLCANDIDS "Filters for SWscores and lengths: $filterRepeatMasker and $minLenPred - for a \"short\" prediction (length < $minLenPred), its SWscore must be >= $minSwscore.\n\n"; }

my @auxSorted = sort{ $a->{from} <=> $b->{from} } @candidAllSuperfam;
my @sortedCandidAllSuperfam = ();
foreach my $lineAux (@auxSorted) { push (@sortedCandidAllSuperfam, $lineAux->{line}); }

my $qttCandid = scalar(@sortedCandidAllSuperfam);
for (my $i = 0; $i < $qttCandid-1; $i++) {
    for (my $j = $i+1; $j < $qttCandid; $j++) {
	if ($sortedCandidAllSuperfam[$i] =~ /-->OUT/) { last; }
	if ($sortedCandidAllSuperfam[$j] !~ /-->OUT/) {
		my ($resp, $sense1, $sense2) = verifyOverlap ($tool, $sortedCandidAllSuperfam[$i], $sortedCandidAllSuperfam[$j]);
		if    ($resp eq "II") { $sortedCandidAllSuperfam[$i] .= "-->OUT"; }
		elsif ($resp eq "JJ") { $sortedCandidAllSuperfam[$j] .= "-->OUT"; }
		elsif ($sense1 eq $sense2) { last; }
	}
    }
}

my $numCandid = 0;
for (my $i = 0; $i < $qttCandid; $i++) {
    if ($sortedCandidAllSuperfam[$i] !~ /-->OUT/) {
	$numCandid++;
# for HMMER: Candidate_num - FROM: ff - TO: tt - LENGTH: ll - EVALUE: ev - SENSE: d/r - CLASSIFICATION: sf 
# for RM:    Candidate_num - FROM: ff - TO: tt - LENGTH: ll - SWSCORE: sc - SENSE: d/r - CLASSIFICATION: sf
	if ($sortedCandidAllSuperfam[$i] =~ /Candidate_\d+ - (.*)- $metrics: .* - SENSE: (.*)/) {
		my $idCandid = "CANDIDATE_$numCandid - $1- SENSE: $2";
		print TOOLCANDIDS "$idCandid\n";
		print "$idCandid\n";

#		write the predictions used to generate the candidate
		my @arraySplit = split '\n',$sortedCandidAllSuperfam[$i];
		my $qttSepara = scalar(@arraySplit);
		for (my $j = 1; $j < $qttSepara; $j++) {
			print TOOLCANDIDS "$arraySplit[$j]\n";
			print "$arraySplit[$j]\n";
		}
		print TOOLCANDIDS "\n";
		print "###\n";
	}
    }
}

close (TOOLCANDIDS);

